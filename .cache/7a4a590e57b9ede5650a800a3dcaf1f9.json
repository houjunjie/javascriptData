{"dependencies":[],"generated":{"js":"\"use strict\";\n\n/**\n * 链表 链表存储是一个有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的。\n * 每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称之为指针或链接）组成\n */\n\nfunction LinkedList() {\n  // 辅助类，表示要加入列表的项\n  var Node = function Node(element) {\n    this.element = element;\n    this.next = null;\n  };\n\n  var length = 0; // 存储列表数量的length属性\n  var head = null; // 存储第一个节点的引用，为此可以把这个引用存储在一个称为head的变量中\n\n  /**\n   * 向列表尾部添加一个新的项\n   * @param {*} element \n   */\n  this.append = function (element) {\n    // 创建Node项\n    var node = new Node(element),\n        current = void 0;\n    if (head == null) {\n      //列表中的第一个节点\n      head = node;\n    } else {\n      current = head;\n      // 循环列表，直到找到最后一项\n      while (current.next) {\n        console.log(head, current, element, 'current');\n        current = current.next;\n      }\n      // 找到最后一项，将其next赋为node，建立连接\n      current.next = node;\n    }\n    length++; //更新链表的长度\n  };\n  /**\n   * 向列表的任意位置插入一个新的值\n   */\n  this.insert = function (position, element) {\n    // 检查越界值\n    if (postion >= 0 && postion <= length) {\n      var node = new Node(element),\n          _current = head,\n          _previous = void 0,\n          index = 0;\n\n      if (postion === 0) {\n        node.next = _current;\n        head = node;\n      } else {\n        while (index++ < postion) {\n          // 迭代列表，找到目标位置\n          _previous = _current;\n          _current = _current.next;\n        }\n        // 跳出循环时，current变量将是对想要插入新元素的位置之后一个元素的引用\n        // 而previous将是对想要插入新元素的位置之前一个元素的引用\n        // 在这种情况下，我们要遭previous和current之前见添加新项，\n        // 因此首先需要把新项(node)和当前项链接起来\n        // 然后改变previous和current之间的链接，\n        // 还需要让previous.next指向node\n        node.next = _current;\n        _previous.next = node;\n      }\n\n      length++; // 更新列表长度\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * 从列表的特定位置移除一项\n   * @param {*} position \n   */\n  this.removeAt = function (position) {\n    // 检查越界值 验证这个位置是否有效\n    if (postion > -1 && postion < length) {\n      // 创建一个对列表中第一个元素的引用，这样current变量就是对列表中第一个元素的引用。\n\n      var _current2 = head,\n          _previous2 = void 0,\n          //前一个元素的引用\n      index = 0;\n\n      // 移除第一项 \n\n      if (position === 0) {\n        //  如果把head赋为current，就会移除第一个元素\n        head = _current2.next;\n      } else {\n        // 迭代列表（使用一个用于内部控制和递增的index变量），直到到达指定位置\n        while (index++ < position) {\n          // 当前元素的前一个元素的引用\n          _previous2 = _current2;\n          // current 变量总是为对所循环列表的当前元素的引用\n          _current2 = _current2.next;\n        }\n\n        // 将previous与current的下一项连接起来，跳过current，从而删除它\n        _previous2.next = _current2.next;\n      }\n      length--;\n      return _current2.element;\n    } else {\n      return null;\n    }\n  };\n  /**\n   * 从列表中移除一项\n   * @param {*} element \n   */\n  this.remove = function (element) {\n    var index = this.indexOf(element);\n    return this.removeAt(index);\n  };\n  /**\n   * 返回元素在列表中的索引，如果列表中没有改元素，则返回-1\n   * @param {*} element \n   */\n  this.indexOf = function (element) {\n    var current = head,\n        index = 0;\n    while (current) {\n      if (element === current.element) {\n        return index;\n      }\n      index++;\n      current = current.next;\n    }\n    return -1;\n  };\n  /**\n   * 如果链表中不包含任何的元素，返回true，链表length长度大于0，返回false\n   */\n  this.isEmpty = function () {\n    return length === 0;\n  };\n  /**\n   * 返回链表中包含元素的个数，与数组的length类似\n   */\n  this.size = function () {\n    return length;\n  };\n  /**\n   * \n   */\n  this.getHead = function () {\n    return head;\n  };\n  /**\n   * 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值\n   * toString把链接对象转换成一个字符串\n   */\n  this.toString = function () {\n    var current = head,\n        string = '';\n    while (current) {\n      string += current.element + (current.next ? 'n' : '');\n      current = current.next;\n    }\n    return string;\n  };\n  this.print = function () {};\n}\n\nvar list = new LinkedList();\nlist.append(15);\nlist.append(10);\nlist.append(20);\nconsole.log(list.indexOf(15));\nconsole.log(list.size());\n\nconsole.log('---------- 双向链表 DoublyLinkedList -------------');\n\nfunction DoublyLinkedList() {\n  var node = function node(element) {\n    this.element = element;\n    this.next = null;\n    this.prev = null;\n  };\n\n  var index = 0;\n  var head = null;\n  var tail = null; // 最后的元素指针\n\n\n  /**\n   * 在任意位置插入新元素\n   */\n  this.insert = function (postion, element) {\n    // 检查越界值\n    if (postion >= 0 && position <= length) {\n      var _node = new Node(element);\n      current = head, previous, index = 0;\n\n      if (postion === 0) {\n        if (!head) {\n          //新增的\n          head = _node;\n          tail = _node;\n        } else {\n          _node.next = current;\n          current.prev = _node; //新增的\n          head = _node;\n        }\n      } else if (postion === length) {\n        // 最后一项 //新增的\n        current = tail;\n        current.next = _node;\n        _node.prev = current;\n        tail = _node;\n      } else {\n        // 迭代列表，找到指定位置的元素\n        while (index++ < postion) {\n          previous = current;\n          current = current.next;\n        }\n        _node.next = current;\n        previous.next = _node;\n\n        current.prev = _node; //\n        _node.prev = previous;\n      }\n      length++;\n\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  this.removeAt = function (postion) {\n    // 检查越界值\n    if (postion > -1 && position < length) {\n      var _current3 = head,\n          _previous3 = void 0,\n          _index = 0;\n\n      // 移除第一项\n      if (postion === 0) {\n        head = _current3.next;\n\n        // 如果只有一项，更新tail（最后一项）\n        if (length === 1) {\n          tail = null;\n        } else {\n          head.prev = null;\n        }\n      } else if (postion === length - 1) {\n        // 最后一项\n        _current3 = tail;\n        tail = _current3.prev;\n        tail.next = null;\n      } else {\n        while (_index++ < postion) {\n          _previous3 = _current3;\n          _current3 = _current3.next;\n        }\n        // 将previous与current的下一项链接起来--跳过current\n        _previous3.next = _current3.next;\n        _current3.next.prev = _previous3;\n      }\n      length--;\n\n      return _current3.element;\n    } else {\n      return null;\n    }\n  };\n}"},"hash":"7272ff872f6efc58100b942b2fc1d86b"}