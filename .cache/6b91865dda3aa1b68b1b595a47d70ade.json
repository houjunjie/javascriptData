{"dependencies":[],"generated":{"js":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// 队列\n\nfunction Queue() {\n  // 这里是属性和方法\n  var items = [];\n  this.enqueue = function (element) {\n    //想队列添加元素\n    items.push(element);\n  };\n\n  this.dequeue = function () {\n    // 从队列中移除元素\n    // 因为队列遵循先进先出原则，所以用数组的shift 不用pop\n    return items.shift();\n  };\n\n  this.front = function () {\n    //查看对列头部元素\n    return items[0];\n  };\n\n  this.isEmpty = function () {\n    //查看队列是否为空\n    return items.length == 0;\n  };\n\n  this.size = function () {\n    //获取队列的长度 也就是Array的length\n    return items.length;\n  };\n\n  this.print = function () {\n    //打印队列元素\n    console.log(items.toString());\n  };\n}\n\nvar queue = new Queue();\nconsole.log('isEmpty', queue.isEmpty());\n\nqueue.enqueue('hou');\nqueue.enqueue('jun');\nqueue.enqueue('jie');\n\nqueue.print();\nconsole.log('size', queue.size());\nconsole.log('isEmpty', queue.isEmpty());\nqueue.dequeue();\nqueue.dequeue();\nqueue.print();\nconsole.log('----------------- es6 实现 ------------------');\n// es6 实现\nvar Queue2 = function () {\n  var items = new WeakMap();\n\n  var Queue2 = function () {\n    function Queue2() {\n      _classCallCheck(this, Queue2);\n\n      items.set(this, []);\n      console.log(items);\n    }\n\n    _createClass(Queue2, [{\n      key: \"enqueue\",\n      value: function enqueue(element) {\n        //向队列添加元素\n        var q = items.get(this);\n        q.push(element);\n      }\n      // 从队列删除元素\n\n    }, {\n      key: \"dequeue\",\n      value: function dequeue() {\n        var q = items.get(this);\n        return q.shift();\n      }\n      // 查看队列头元素\n\n    }, {\n      key: \"front\",\n      value: function front() {\n        var q = items.get(this);\n        return q[0];\n      }\n      // 查看队列是否为空\n\n    }, {\n      key: \"isEmpty\",\n      value: function isEmpty() {\n        var q = items.get(this);\n        return q.length == 0;\n      }\n      // 查看队列长度\n\n    }, {\n      key: \"size\",\n      value: function size() {\n        var q = items.get(this);\n        return q.length;\n      }\n      // 打印队列元素\n\n    }, {\n      key: \"print\",\n      value: function print() {\n        var q = items.get(this);\n        console.log(q.toString());\n      }\n    }]);\n\n    return Queue2;\n  }();\n\n  return Queue2;\n}();\n\nvar queue2 = new Queue2();\nconsole.log('isEmpty', queue2.isEmpty());\n\nqueue2.enqueue('hou');\nqueue2.enqueue('jun');\nqueue2.enqueue('jie');\n\nqueue2.print();\nconsole.log('size', queue2.size());\nconsole.log('isEmpty', queue2.isEmpty());\nqueue2.dequeue();\nqueue2.dequeue();\nqueue2.print();\n\nconsole.log('-------------- 优先队列 PriorityQueue ---------------');\n\n/**\n * 优先队列 有两种实现方式 \n * 1 设置优先级，然后在正确的位置添加元素\n * 2 或者用入列操作添加元素，然后按照优先级移除它们\n */\nfunction PriorityQueue() {\n  var items = [];\n  // 创建一个特殊元素用来添加到队列，改元素包含了要添加到队列的元素（任意类型）还有它在队列中的优先级\n  function QueueElement(element, priority) {\n    this.element = element;\n    this.priority = priority;\n  }\n  this.enqueue = function (element, priority) {\n    var queueElement = new QueueElement(element, priority);\n\n    var added = false;\n    for (var i = 0; i < items.length; i++) {\n      // 比较该元素与其它元素的优先级，当找到一个元素的priority值更大（优先级更低），就把新元素插入到它之前\n      if (queueElement.priority < items[i].priority) {\n        items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n    if (!added) {\n      items.push(queueElement);\n    }\n  };\n  // 从队列中删除元素\n  this.dequeue = function () {\n    return items.shift();\n  };\n\n  // 查看队列头元素\n  this.front = function () {\n    return items[0];\n  };\n\n  // 队列是否为空\n  this.isEmpty = function () {\n    return items.length == 0;\n  };\n\n  // 队列长度\n  this.size = function () {\n    return items.length;\n  };\n\n  // 打印队列元素\n  this.print = function () {\n    for (var i = 0; i < items.length; i++) {\n      console.log(items[i].element + \" - \" + items[i].priority);\n    }\n  };\n}\nvar priorityQueue = new PriorityQueue();\nconsole.log('isEmpty', priorityQueue.isEmpty());\npriorityQueue.enqueue('jun', 2);\npriorityQueue.enqueue('hou', 1);\npriorityQueue.enqueue('jie', 3);\npriorityQueue.print();\n\nconsole.log('---------- 循环队列-击鼓传花 hotPotato -----------');\n\n/**\n * 击鼓传花 -- 孩子围成一个圆圈， 把花尽快地传递给旁边的人。某一时刻传花停止，\n * 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子\n * 循环队列 -- 迭代一个列表，从开头移除一项，再将其添加到队列末尾。\n * 一旦传递次数到了给定的数字，就移除，直到最后一个元素\n * @param {*} nameList \n * @param {*} num \n */\nfunction hotPotato(nameList, num) {\n  // 借助一个之前实现的队列\n  var queue = new Queue();\n  for (var i = 0; i < nameList.length; i++) {\n    // 把这个列表的元素加入队列\n    queue.enqueue(nameList[i]);\n  }\n\n  var eliminated = '';\n  while (queue.size() > 1) {\n    for (var _i = 0; _i < num; _i++) {\n      // 从队列开头移除一项，再将其添加到队列末尾\n      queue.enqueue(queue.dequeue());\n    }\n    // 一旦传递次数达到给定数字， 从队列移除\n    eliminated = queue.dequeue();\n    console.log(eliminated + '在击鼓传花游戏中被淘汰');\n  }\n  // 胜者\n  return queue.dequeue();\n}\n\nvar names = ['john', 'jack', 'hou', 'jun', 'jie'];\nvar winner = hotPotato(names, 7);\nconsole.log('the winner is: ' + winner);"},"hash":"867948d0bb1ca3b5c741488c0a94acd3"}