###字典
####描述
> 字典中，存储的是`[键, 值]`对，其中键名是用来查询特定元素的。字典好集合很相似，集合是以`[值, 值]`存储元素的，字典则是`[键, 值]`存储元素，字典也称之为`映射`

####创建字典
实现一个字典
以下是字典的骨架
```
function Dictionary () {
	let items = {}
}
```
声明一些映射/字典所能使用的方法

	1. Set(key, value): 向字典中添加新元素
	2. delete(key) 通过使用键值从字典中删除键值以及键值对应的数据值
	3. has(key) 如果某个键值存在字典中，返回true，否则返回false
	4. get(key) 通过键值查找特定的数值并返回
	5. clear() 将这个字典中所有的元素删除
	6. size() 返回这个字典所包含的元素数量，与数组的length类似
	7. keys() 将字典中所有的键名以数组形式返回
	8. values() 将字典中所有数组以数组形式返回

详细请看`dictionary.js`


####散列表
散列表属于字典中的一种
> `散列算法`的作用是尽可能快地在数据结构中找到一个值
在我们实现的Dictionart类中，我们要获得一个值(get方法)，需要遍历整个数据结构来找到他。如果使用散列函数，就知道值的具体位置，因此能快速检索到该值 ????这句话有点问题。我测试了一下在字典中获取值的get方法是用的in或者hasOwnProperty来查找。速度是差不多。并没有明显优势。难道in,或者hasOwnProperty不是遍历整个数据结构吗？这个有点疑问
散列函数的作用是给定一个键值，然后返回值在表中的地址。

实现散列表 `HashTable`

```
function HashTbale () {
	let table = [];
}
```

我们给这个类实现三个基本方法

	1. put(key, value) 向散列表增加一个新的项，（也可能是更新散列表）
	2. remove(key) 根据键值从散列表中移除值
	3. get(key) 返回根据键值检索到的特定的值

具体实现请看`dictionary.js`

####散列集合
> `散列集合` 是由一个集合构成的，但是插入，移除或获取元素时，使用的是散列函数。


我们使用散列函数来生成一个散列值，这个值有可能是相同的。为了解决这种冲突我们有以下解决方法
> 1. 分离链接
> 2. 线性探查

######分离链接
分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单方法，但是它在HashTable实例之外还需要额外的存储空间

为实现一个使用了分离链接的HashTable实例，我们需要一个新的辅助类来表示将要加入LinkedList实例的元素。叫ValuePair类（在HashTable类内部定义）

######线性探查
线性探查：如果在向表中某个位置添加新元素的时候，如果发现该位置下标索引`index`已经被占据，那么我们尝试在索引`index+1`尝试。如果`index+1`也被占据，则尝试`index+2`，以此类推


####ES6 -- Map类
我们可以用Map类来开发我们的Dictionary类；
和我们Dictionary类不一样的是，ES6的Map类的`values`方法和`keys`方法都返回`Iterator`(迭代器)，而不是值或构成的数组。另一个区别是，我们实现的size方法返回字典中存储的值的个数，而ES6的Map类则有一个`size`属性
